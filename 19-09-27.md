# Union-Find Data Structure [ 2019-09-27 ]

### 공부 이유 : 
-------------------------
유니온 파인드를 공부해놓으면 다양한 알고리즘 문제에 적용해서 풀지 않을까 생각을 해서 오늘은 유니온 파인드를 공부해보았습니다.


### 공부 내용 :
-------------------------
#### Union-Find 란?

서로소 집합 그리고 병합 찾기 집합이라고도 불리며 여러 서로소 집합의 정보를 저장하고 있는 자료구조를 의미한다.<br>
정의만 봤을때 쉽게 안될 수 있지만 간단하게 풀이해보자면 서로 연결된 컴포넌트들끼리 하나의 집합으로 묶는다고 생각하면 된다.<br>
이렇게 집합을 묶게 된다면 집합들 간에는 교집합이 발생하지 않게 된다.<br>

아래 그림을 통해서 간단하게 확인해 봅시다.<br>
연결 노드<br>
1-3<br>
2-5<br>
3-6<br>
6-7<br>
-------------------------------------------

![유니온파인드](https://user-images.githubusercontent.com/35329247/65747089-8445d580-e13b-11e9-99d5-db24f4610517.gif)


그림처럼 총 3개의 서로소 집합이 생기는것을 볼 수 있다.

구현 
배열을 이용해서 Tree 자료구조를 만들어 구현하면 위에 나와 있는 아래 표처럼 표현 및 구현이 가능하다.<br>
즉, 최상단 노드인 Root 노드를 집합을 구분하는 ID처럼 생각하면 이해가 더 편하다.

소스 구현은 3개 메소드만 구현하면 된다.

### 1. 초기화 과정 (Init) <br>
사용하기전에 먼저 현재 노드의 부모 노드가 자기자신으로 초기화를 해준다.

~~~
for ( int i = 1; i <= N; i++){
  parent[i] = i;
}
~~~


### 2. 파인드 과정 (Find) <br>
현재 노드에 부모 노드 값을 리턴해주는 함수

~~~
if ( u == parent[u]) return u;

return parent[u] = find(parent[u]);
~~~

### 3. 유니온 과정 (Union) <br>
두 집합을 합쳐주는 함수

~~~
u = find(u);
v = find(v);

//두 노드 부모 값이 같다면 리턴
if(u == v) return;

//v가 더 작다면 u에 부모 값으로 설정
if(u > v) parent[u] = v;
//u가 더 작다면 v에 부모 값으로 설정
else parent[v] = u;
~~~

### 마치며...
-------------------------------

유니온 파인드 자료구조는 매우 간단하면서 좋은 효율을 자랑한다.<br>
시간복잡도를 계산해보면  <br>
find::O(lgN)  <br>
union::O(lgN) <br>
실제로 find 연산은 호출할 때마다 수행 시간이 변한다. <br>
따라서 매우 까다로운 시간 복잡도를 가지고 있는데 실제 시간 복잡도는 O(a(N))이라고 한다. <br> 
<strong>a는 애커만 함수</strong>라고 하는데 N이 2^65536일때 애커만 함수 값이 5가 된다.<br>
따라서 그냥 상수라고 봐도 무방하다. <br>





